### Guideline from Defining Smart Contract Defects on Ethereum (Chen et al.) [1]

(1) Unchecked External Calls: To transfer Ethers or call functions of other smart contracts, Solidity provides a series of external call functions for raw addresses, i.e., address.send(), address.call(), address.delegatecall()[5]. Unfortunately, these methods may fail due to network errors or out-of-gas error, e.g., the 2300 gas limitation of fallback function introduced in Section 2. When errors happen, these methods will return a boolean value (False), but never throw an exception. If callers do not check return values of external calls, they cannot ensure whether code logic is correct. Example: An example of this defect is given in Listing 1. In function getWinner (L23), the contract does not check the return value of send (L26), but the array participants is emptied by assigning participatorID to 0 (L25). In this case, if the send method failed, the winner will lose 8 Ethers. Possible Solution: Using address.transfer() to instead address.send() and address.call.value() if possible, or checking the return value of send and call.

(2) DoS Under External Influence: When an exception is detected, the smart contract will roll back the transaction. However, throwing exceptions inside a loop is dangerous. Example: In line 33 of Listing 1, the contract uses transfer to send Ethers. However, In Solidity, transfer and send will limit the gas of fallback function in callee contracts to 2,300 gas [5]. This gas is not enough to write to storage, call functions or send Ethers. If one of member[i] is an attacker’s smart contract and the transfer function (L33) can trigger an out-of-gas exception due to the 2,300 gas limitation. Then, the contract state will roll back. Since the code cannot be modified, the contract cannot remove the attacker from members list, which means that if the attacker does not stop attacking, no one can get bonus anymore. Possible Solution: Avoid throwing exceptions in the body of a loop. We can return a boolean value instead of throwing an exception. For example, using “if(msg.send(...) == false) break;” instead of using “msg.transfer(...)”.

(3) Strict Balance Equality: Attackers can send Ethers to any contracts forcibly by utilizing selfdestruct(victim address) API [5]. This way will not trigger the fallback function, meaning the victim contract cannot reject the Ethers. Therefore, the logic of equal balance check will fail to work due to the unexpected ethers sent by attackers. Example: Attackers can send 1 Wei (1 Ether = 10^18 Wei) to Contract Gamble in Listing 1 by utilizing selfdestruct method. This method will not trigger fallback function (L13). Thus, the Ethers will not be thrown by ReceiveEth (L16). If this attack happens, the getWinner() (L23) would never be executed because the getWinner can only be executed when the balance of the contract is strictly equal to 10 Ethers (L21). Possible Solution: Since the attackers can only add the amount of the balance, we can use a range to replace “==”. In this case, attackers cannot affect the logic of the programs. Using the defect in Listing 1 as an example, we can modify the code in L21 to “if (this.balance ≥ 10 ether && this.balance < 11 ether)”

(4) Unmatched Type Assignment: Solidity supports different types of integers (e.g., uint8, uint256). The default type of integer is uint256 which supports a range from 0 to 2^256. uint8 takes less memory but only supports numbers from 0 to 2^8. Solidity will not throw an exception when a value exceeds its maximum value. The progressive increase is a common operation in programming, and performing an increment operation without checking the maximum value may lead to overflow. Example: The variable i in line 30 of Listing 1 is assigned to uint8 because 0 is in the range of uint8 (0-255). If the members.length is larger than 255, the value of i after 255 is 0. Thus, the loop will not stop until running out of gas or the balance of the account is less than 0.1. Possible Solution: Using uint or uint256 if we are not sure of the maximum number of loop iterations.

(5) Transaction State Dependency: Contracts need to check whether the caller has permissions in some functions like suicide (L33 in Listing 1). The failure of permission checks can cause serious consequences. For example, if someone passes the permission check of suicide function, he/she can destroy the contract and steal all the Ethers. tx.origin can get the original address that kicked off the transaction, but this method is not reliable since the address returned by this method depends on the transaction state. Example: We can find this defect in line 8 of Listing 1. The contract uses tx.origin to check whether the caller has permission to execute function suicide (L35). However, if an attacker uses function attack in Listing 4 to call suicide function (L35 in Listing 1), the permission check will fail. The suicide function will check whether the sender has permission to execute this function. However, the address obtained by tx.origin is always the address who creates this contract (0xdCad...d1D3ADL12 in Listing 1). Therefore, anyone can execute the suicide function and withdraw all of the Ethers in the contract. Possible Solution: Using msg.sender to check the permission instead of using tx.origin.

(6) Block Info Dependency: Ethereum provides a set of APIs (e.g., block.blockhash, block.timestamp) to help smart contracts obtain block-related information, like timestamps or hash numbers. Many contracts use these pieces of block information to execute some operations. However, the miner can influence block information; for example, miners can vary block timestamp by roughly 900 seconds [24]. In other words, block info dependency operations can be controlled by miners to some extent. Example: In Listing 1 line 25, the contract uses blockhash to generate which member is the winner. However, the gamble is not fair because miners can manipulate this operation. Possible Solution: To generate a safer random number in Solidity, we should ensure the random number cannot be controlled by a single person, e.g., a miner. We can use the information of users like their addresses as their input numbers, as their distributions are completely random. Also, to avoid attacks, we need to hide the values we used from other players. Since we cannot hide the address of users and their submitted values, a possible solution to generate a random number without using block-related APIs using a hash number. The algorithm has three rounds:

Round 1: Users obtain a random number and generate a hash value on their local machine. The hash value can be obtained by keccak256, which is provided by Solidity. After obtaining the random number, users submit the hash number.

Round 2: After all users submit their hash number, users are required to submit their original random number. The contract checks whether the original number can generate the same hash number.

Round 3: If all users submit the correct original numbers, the contract can use the original numbers to generate a random number.

(7) Re-entrancy: Concurrency is an important feature of traditional software. However, Solidity does not support it, and the functions of a smart contract can be interrupted while running. Solidity allows parallel external invocations using call method. If the callee contract does not correctly manage the global state, the callee contract will be attacked – called a re-entrancy attack. Example: Listing 2 shows an example of re-entrancy. The Attacker contract invokes Victim contract’s withdraw() function in Line 11. However, Victim contract sends Ethers to attacker contract (L6) before resetting the balance (L7). Line 6 will invoke the fallback function (L9) of attacker contract and lead to repeated invocation. Possible Solution: Using send() or transfer to transfer Ethers. send() and transfer have gas limitation of 2300 if the recipient is a contract account, which are not enough to transfer Ethers. Therefore, these two functions will not cause Re-entrancy.

(8) Nested Call: Instruction CALL is very expensive (9000 gas paid for a non-zero value transfer as part of the CALL operation [3]). If a loop body contains CALL operation but does not limit the number of times the loop is executed, the total gas cost would have a high probability of exceeding the gas limitation because the number of iterations may be high and it is hard to know its upper limit. Example: In Listing 1, the function giveBonus (line 28) uses transfer (L33) which generates CALL to send Ethers. Since the members.length (L30) does not limit its size, giveBonus has a probability to cause out-of-gas error. When this error happens, this function cannot be called anymore because there is no way to reduce the members.length. Possible Solution: The developers should estimate the maximum number of loop iterations that can be supported by the contract and limit these loop iterations.

(9) Misleading Data Location: In traditional programming languages like Java or C, variables created inside a function are local variables. Data is stored in memory, and the memory will be released after the function exits. In Solidity, the data of struct, mapping, arrays are stored in storage even if they are created inside a function. However, since storage in Solidity is not dynamically allocated, storage variables created inside a function will point to the storage slot 50 by default [5]. This can cause unpredictable bugs. Example: Function reAssignArray (L6) in Listing 3 creates a local variable tmp. The default data location of tmp is storage, but EVM cannot allocate storage dynamically. There is no space for tmp, but instead, it will point to the storage slot 0 (variable in L3 of Listing 3). For the result, once function reAssignArray is called, the variable variable will add 1, which can cause bugs for the contract. Possible Solution: Clarifying the data location of struct, mapping, and arrays if they are created inside a function.
